<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Graphics.Rendering.Diagrams.Monoids</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Graphics-Rendering-Diagrams-Monoids.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Graphics-Rendering-Diagrams-Monoids.html">Source</a></li><li><a href="http://www.haskell.org/haskellwiki/Diagrams/Comments/Graphics.Rendering.Diagrams.Monoids">User Comments</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-core-0.5: Core libraries for diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Graphics.Rendering.Diagrams.Monoids</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Monoids and semigroups
</a></li><li><a href="#g:2">Monoid actions
</a></li><li><a href="#g:3">Split monoids
</a></li><li><a href="#g:4">Forgetful monoids
</a></li><li><a href="#g:5">Applicative monoids
</a></li><li><a href="#g:6">Coproduct monoid
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Various monoid-related definitions (monoid actions, split monoids,
 applicative monoids) used in the core diagrams library.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="#t:Monoid-39-">Monoid'</a> m </li><li class="src short"><span class="keyword">class</span>  <a href="#t:Action">Action</a> m s  <span class="keyword">where</span><ul class="subs"><li><a href="#v:act">act</a> :: m -&gt; s -&gt; s</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Split">Split</a> m<ul class="subs"><li>= <a href="#v:M">M</a> m  </li><li>| m <a href="#v::-124-">:|</a> m  </li></ul></li><li class="src short"><a href="#v:split">split</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Forgetful">Forgetful</a> m<ul class="subs"><li>= <a href="#v:Normal">Normal</a> m  </li><li>| <a href="#v:Forgetful">Forgetful</a> m  </li></ul></li><li class="src short"><a href="#v:unForget">unForget</a> ::  <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m -&gt; m</li><li class="src short"><a href="#v:forget">forget</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Deletable">Deletable</a> m = <a href="#v:Deletable">Deletable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Int.html#t:Int">Int</a> m <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:unDelete">unDelete</a> ::  <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m -&gt; m</li><li class="src short"><a href="#v:toDeletable">toDeletable</a> ::  m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m</li><li class="src short"><a href="#v:deleteL">deleteL</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m</li><li class="src short"><a href="#v:deleteR">deleteR</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:AM">AM</a> f m = <a href="#v:AM">AM</a> (f m)</li><li class="src short"><a href="#v:inAM2">inAM2</a> ::  (f m -&gt; f m -&gt; f m) -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m</li><li class="src short"><span class="keyword">data</span>  m <a href="#t::-43-:">:+:</a> n</li><li class="src short"><a href="#v:inL">inL</a> ::  m -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n</li><li class="src short"><a href="#v:inR">inR</a> ::  n -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n</li><li class="src short"><a href="#v:mappendL">mappendL</a> ::  m -&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n</li><li class="src short"><a href="#v:mappendR">mappendR</a> ::  n -&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n</li><li class="src short"><a href="#v:killL">killL</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; n</li><li class="src short"><a href="#v:killR">killR</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m</li><li class="src short"><a href="#v:untangle">untangle</a> :: (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n) =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; (m, n)</li></ul></div><div id="interface"><h1 id="g:1">Monoids and semigroups
</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a name="t:Monoid-39-" class="def">Monoid'</a> m <a href="src/Graphics-Rendering-Diagrams-Monoids.html#Monoid%27" class="link">Source</a></p><div class="doc"><p>The <code>Monoid'</code> class is a synonym for things which are instances
   of both <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> and <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code>.  Ideally, the <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code> class
   itself will eventually include a <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code> superclass and we
   can get rid of this.
</p></div><div class="subs instances"><p id="control.i:Monoid-39-" class="caption collapser" onclick="toggleSection('i:Monoid-39-')">Instances</p><div id="section.i:Monoid-39-" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Monoid-39-">Monoid'</a> m</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Monoid actions
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Action" class="def">Action</a> m s  <span class="keyword">where</span><a href="src/Graphics-Rendering-Diagrams-Monoids.html#Action" class="link">Source</a></p><div class="doc"><p>Type class for monoid actions, where monoidal values of type <code>m</code>
   &quot;act&quot; on values of another type <code>s</code>.  Instances are required to
   satisfy the laws
</p><ul><li><pre>act mempty = id</pre></li><li><pre>act (m1 `<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code>` m2) = act m1 . act m2</pre></li></ul><p>Additionally, if the type <code>s</code> has any algebraic structure, <code>act
   m</code> should be a homomorphism.  For example, if <code>s</code> is also a
   monoid we should have <code>act m mempty = mempty</code> and <code>act m (s1
   `<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code>` s2) = (act m s1) `<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code>` (act m s2)</code>.
</p><p>By default, <code>act = const id</code>, so for a monoidal type <code>M</code> which
   should have no action on anything, it suffices to write
</p><pre> instance Action M s
</pre><p>with no method implementations.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:act" class="def">act</a> :: m -&gt; s -&gt; s<a href="src/Graphics-Rendering-Diagrams-Monoids.html#act" class="link">Source</a></p><div class="doc"><p>Convert a monoidal value of type <code>m</code> to an action on <code>s</code> values.
</p></div></div><div class="subs instances"><p id="control.i:Action" class="caption collapser" onclick="toggleSection('i:Action')">Instances</p><div id="section.i:Action" class="show"><table><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> <a href="Graphics-Rendering-Diagrams-Names.html#t:Name">Name</a> a</td><td class="doc"><p>Names don't act on anything else.
</p></td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> <a href="Graphics-Rendering-Diagrams-MList.html#t:Nil">Nil</a> l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> <a href="Graphics-Rendering-Diagrams-Names.html#t:Name">Name</a> (<a href="Graphics-Rendering-Diagrams-Names.html#t:NameMap">NameMap</a> v)</td><td class="doc"><p>A name acts on a name map by qualifying every name in it.
</p></td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m) n</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m) n</td><td class="doc"><p>By default, the action of a split monoid is the same as for
   the underlying monoid, as if the split were removed.
</p></td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Transform.html#t:HasLinearMap">HasLinearMap</a> v, ~ * v (<a href="Graphics-Rendering-Diagrams-V.html#t:V">V</a> a), <a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformable">Transformable</a> a) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformation">Transformation</a> v) a</td><td class="doc"><p>Transformations can act on transformable things.
</p></td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Style.html#t:Style">Style</a> v) m</td><td class="doc"><p>Styles have no action on other monoids.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> a =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-MList.html#t:SM">SM</a> a) <a href="Graphics-Rendering-Diagrams-MList.html#t:Nil">Nil</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> a a', <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-MList.html#t:SM">SM</a> a) l) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-MList.html#t:SM">SM</a> a) (<a href="Graphics-Rendering-Diagrams-MList.html#t::::">:::</a> a' l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m r, <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> n r) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> m n) r</td><td class="doc"><p>Coproducts act on other things by having each of the components
   act individually.
</p></td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Foldable.html#t:Foldable">Foldable</a> f, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> f, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m) n</td><td class="doc"><p>An applicative monoid acts on a value of a monoidal type by
   having each element in the structure act on the value
   independently, and then folding the resulting structure.
</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> a, <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-MList.html#t:SM">SM</a> a) l2, <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> l1 l2) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-MList.html#t::::">:::</a> a l1) l2</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Split monoids
</h1><div class="doc"><p>Sometimes we want to accumulate values from some monoid, but have
 the ability to introduce a &quot;split&quot; which separates values on
 either side.  For example, this is used when accumulating
 transformations to be applied to primitive diagrams: the <code>freeze</code>
 operation introduces a split, since only transformations occurring
 outside the freeze should be applied to attributes.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Split" class="def">Split</a> m <a href="src/Graphics-Rendering-Diagrams-Monoids.html#Split" class="link">Source</a></p><div class="doc"><p>A value of type <code>Split m</code> is either a single <code>m</code>, or a pair of
   <code>m</code>'s separated by a divider.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:M" class="def">M</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">m <a name="v::-124-" class="def">:|</a> m</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Split" class="caption collapser" onclick="toggleSection('i:Split')">Instances</p><div id="section.i:Split" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m)</td><td class="doc"><p>If <code>m</code> is a <code>Semigroup</code>, then <code>Split m</code> is a semigroup which
   combines values on either side of a split, keeping only the
   rightmost split.
</p></td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m) n</td><td class="doc"><p>By default, the action of a split monoid is the same as for
   the underlying monoid, as if the split were removed.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Graphics-Rendering-Diagrams-UDTree.html#t:UDTree">UDTree</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:UpAnnots">UpAnnots</a> v m) (<a href="Graphics-Rendering-Diagrams-Core.html#t:DownAnnots">DownAnnots</a> v) (<a href="Graphics-Rendering-Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:split" class="def">split</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Split">Split</a> m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#split" class="link">Source</a></p><div class="doc"><p>A convenient name for <code>mempty :| mempty</code>, so <code>a &lt;&gt; split &lt;&gt; b == a :| b</code>.
</p></div></div><h1 id="g:4">Forgetful monoids
</h1><div class="doc"><p>Sometimes we want to be able to &quot;forget&quot; some information.  We
 define two monoid transformers that allow forgetting information.
 <code>Forgetful</code> introduces special values which cause anything to their
 right to be forgotten.  <code>Deletable</code> introduces special &quot;left and
 right bracket&quot; elements which cause everything inside them to be
 forgotten.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Forgetful" class="def">Forgetful</a> m <a href="src/Graphics-Rendering-Diagrams-Monoids.html#Forgetful" class="link">Source</a></p><div class="doc"><p>A value of type <code>Forgetful m</code> is either a &quot;normal&quot; value of
   type <code>m</code>, which combines normally with other normal values, or a
   &quot;forgetful&quot; value, which combines normally with other values to
   its left but discards values combined on the right.  Also, when
   combining a forgetful value with a normal one the result is
   always forgetful.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Normal" class="def">Normal</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Forgetful" class="def">Forgetful</a> m</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Forgetful" class="caption collapser" onclick="toggleSection('i:Forgetful')">Instances</p><div id="section.i:Forgetful" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m)</td><td class="doc"><p>If <code>m</code> is a <code><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code>, then <code>Forgetful m</code> is a semigroup with two
   sorts of values, &quot;normal&quot; and &quot;forgetful&quot;: the normal ones
   combine normally and the forgetful ones discard anything to the
   right.
</p></td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformable">Transformable</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformable">Transformable</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m) n</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:unForget" class="def">unForget</a> ::  <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m -&gt; m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#unForget" class="link">Source</a></p><div class="doc"><p>Project the wrapped value out of a <code><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a></code> value.
</p></div></div><div class="top"><p class="src"><a name="v:forget" class="def">forget</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Forgetful">Forgetful</a> m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#forget" class="link">Source</a></p><div class="doc"><p>A convenient name for <code>Forgetful mempty</code>, so <code>a &lt;&gt; forget &lt;&gt;
   b == Forgetful a</code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Deletable" class="def">Deletable</a> m <a href="src/Graphics-Rendering-Diagrams-Monoids.html#Deletable" class="link">Source</a></p><div class="doc"><p>If <code>m</code> is a <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a></code>, then <code>Deletable m</code> (intuitively speaking)
   adds two distinguished new elements <code>[</code> and <code>]</code>, such that an
   occurrence of [ &quot;deletes&quot; everything from it to the next ]. For
   example,
</p><pre> abc[def]gh == abcgh
</pre><p>This is all you really need to know to <em>use</em> <code>Deletable m</code>
   values; to understand the actual implementation, read on.
</p><p>To properly deal with nesting and associativity we need to be
   able to assign meanings to things like <code>[[</code>, <code>][</code>, and so on. (We
   cannot just define, say, <code>[[ == [</code>, since then <code>([[)] == [] ==
   id</code> but <code>[([]) == [id == [</code>.)  Formally, elements of <code>Deletable
   m</code> are triples of the form (r, m, l) representing words <code>]^r m
   [^l</code>.  When combining two triples (r1, m1, l1) and (r2, m2, l2)
   there are three cases:
</p><ul><li> If l1 == r2 then the [s from the left and ]s from the right
     exactly cancel, and we are left with (r1, m1 &lt;&gt; m2, l2).
</li><li> If l1 &lt; r2 then all of the [s cancel with some of the ]s, but
     m1 is still inside the remaining ]s and is deleted, yielding (r1
     + r2 - l1, m2, l2)
</li><li> The remaining case is symmetric with the second.
</li></ul></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Deletable" class="def">Deletable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Int.html#t:Int">Int</a> m <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Deletable" class="caption collapser" onclick="toggleSection('i:Deletable')">Instances</p><div id="section.i:Deletable" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformable">Transformable</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Transform.html#t:Transformable">Transformable</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Graphics-Rendering-Diagrams-UDTree.html#t:UDTree">UDTree</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:UpAnnots">UpAnnots</a> v m) (<a href="Graphics-Rendering-Diagrams-Core.html#t:DownAnnots">DownAnnots</a> v) (<a href="Graphics-Rendering-Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:unDelete" class="def">unDelete</a> ::  <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m -&gt; m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#unDelete" class="link">Source</a></p><div class="doc"><p>Project the wrapped value out of a <code><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a></code> value.
</p></div></div><div class="top"><p class="src"><a name="v:toDeletable" class="def">toDeletable</a> ::  m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#toDeletable" class="link">Source</a></p><div class="doc"><p>Inject a value into a <code><a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a></code> wrapper.  Satisfies the
   property
</p><pre> unDelete . toDeletable === id
</pre></div></div><div class="top"><p class="src"><a name="v:deleteL" class="def">deleteL</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#deleteL" class="link">Source</a></p><div class="doc"><p>A &quot;left bracket&quot;, which causes everything between it and the
   next right bracket to be deleted.
</p></div></div><div class="top"><p class="src"><a name="v:deleteR" class="def">deleteR</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Deletable">Deletable</a> m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#deleteR" class="link">Source</a></p><div class="doc"><p>A &quot;right bracket&quot;, denoting the end of the section that should
   be deleted.
</p></div></div><h1 id="g:5">Applicative monoids
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:AM" class="def">AM</a> f m <a href="src/Graphics-Rendering-Diagrams-Monoids.html#AM" class="link">Source</a></p><div class="doc"><p>A wrapper for an <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a></code> structure containing a monoid.
   Such structures have a <code>Monoid</code> instance based on &quot;idiomatic&quot;
   application of <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code> within the <code>Applicative</code> context.
   <code>instance Monoid m =&gt; Monoid (e -&gt; m)</code> is one well-known special
   case.  (However, the standard <code>Monoid</code> instance for <code>Maybe</code> is
   <em>not</em> an instance of this pattern; nor is the standard instance
   for lists.)
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AM" class="def">AM</a> (f m)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:AM" class="caption collapser" onclick="toggleSection('i:AM')">Instances</p><div id="section.i:AM" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> f =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> f, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m)</td><td class="doc"><p><code>f1 `<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code>` f2</code> is defined as <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#v:mappend">mappend</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f1 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> f2</code>.
</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> f, <a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> m) =&gt; <a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Foldable.html#t:Foldable">Foldable</a> f, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Monad.html#t:Functor">Functor</a> f, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m) n</td><td class="doc"><p>An applicative monoid acts on a value of a monoidal type by
   having each element in the structure act on the value
   independently, and then folding the resulting structure.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Graphics-Rendering-Diagrams-UDTree.html#t:UDTree">UDTree</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:UpAnnots">UpAnnots</a> v m) (<a href="Graphics-Rendering-Diagrams-Core.html#t:DownAnnots">DownAnnots</a> v) (<a href="Graphics-Rendering-Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inAM2" class="def">inAM2</a> ::  (f m -&gt; f m -&gt; f m) -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m -&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a> f m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#inAM2" class="link">Source</a></p><div class="doc"><p>Apply a binary function inside an <code><a href="Graphics-Rendering-Diagrams-Monoids.html#t:AM">AM</a></code> newtype wrapper.
</p></div></div><h1 id="g:6">Coproduct monoid
</h1><div class="top"><p class="src"><span class="keyword">data</span>  m <a name="t::-43-:" class="def">:+:</a> n <a href="src/Graphics-Rendering-Diagrams-Monoids.html#%3A%2B%3A" class="link">Source</a></p><div class="doc"><p><code>m :+: n</code> is the coproduct of monoids <code>m</code> and <code>n</code>.  Values of
   type <code>m :+: n</code> consist of alternating lists of <code>m</code> and <code>n</code>
   values.  The empty list is the identity, and composition is list
   concatenation, with appropriate combining of adjacent elements
   when possible.
</p></div><div class="subs instances"><p id="control.i::-43-:" class="caption collapser" onclick="toggleSection('i::-43-:')">Instances</p><div id="section.i::-43-:" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> m n)</td><td class="doc"><p>The coproduct of two monoids is itself a monoid.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> m n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m r, <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> n r) =&gt; <a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> (<a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> m n) r</td><td class="doc"><p>Coproducts act on other things by having each of the components
   act individually.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html#t:Newtype">Newtype</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:QDiagram">QDiagram</a> b v m) (<a href="Graphics-Rendering-Diagrams-UDTree.html#t:UDTree">UDTree</a> (<a href="Graphics-Rendering-Diagrams-Core.html#t:UpAnnots">UpAnnots</a> v m) (<a href="Graphics-Rendering-Diagrams-Core.html#t:DownAnnots">DownAnnots</a> v) (<a href="Graphics-Rendering-Diagrams-Core.html#t:Prim">Prim</a> b v))</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:inL" class="def">inL</a> ::  m -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n<a href="src/Graphics-Rendering-Diagrams-Monoids.html#inL" class="link">Source</a></p><div class="doc"><p>Injection from the left monoid into a coproduct.
</p></div></div><div class="top"><p class="src"><a name="v:inR" class="def">inR</a> ::  n -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n<a href="src/Graphics-Rendering-Diagrams-Monoids.html#inR" class="link">Source</a></p><div class="doc"><p>Injection from the right monoid into a coproduct.
</p></div></div><div class="top"><p class="src"><a name="v:mappendL" class="def">mappendL</a> ::  m -&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n<a href="src/Graphics-Rendering-Diagrams-Monoids.html#mappendL" class="link">Source</a></p><div class="doc"><p>Prepend a value from the left monoid.
</p></div></div><div class="top"><p class="src"><a name="v:mappendR" class="def">mappendR</a> ::  n -&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n<a href="src/Graphics-Rendering-Diagrams-Monoids.html#mappendR" class="link">Source</a></p><div class="doc"><p>Prepend a value from the right monoid.
</p></div></div><div class="top"><p class="src"><a name="v:killL" class="def">killL</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; n<a href="src/Graphics-Rendering-Diagrams-Monoids.html#killL" class="link">Source</a></p><div class="doc"><p><code>killL</code> takes a value in a coproduct monoid and sends all the
   values from the left monoid to the identity.
</p></div></div><div class="top"><p class="src"><a name="v:killR" class="def">killR</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; m<a href="src/Graphics-Rendering-Diagrams-Monoids.html#killR" class="link">Source</a></p><div class="doc"><p><code>killR</code> takes a value in a coproduct monoid and sends all the
   values from the right monoid to the identity.
</p></div></div><div class="top"><p class="src"><a name="v:untangle" class="def">untangle</a> :: (<a href="Graphics-Rendering-Diagrams-Monoids.html#t:Action">Action</a> m n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> m, <a href="http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> n) =&gt; (m <a href="Graphics-Rendering-Diagrams-Monoids.html#t::-43-:">:+:</a> n) -&gt; (m, n)<a href="src/Graphics-Rendering-Diagrams-Monoids.html#untangle" class="link">Source</a></p><div class="doc"><p>Take a value from a coproduct monoid where the left monoid has an
   action on the right, and &quot;untangle&quot; it into a pair of values.  In
   particular,
</p><pre> m1 &lt;&gt; n1 &lt;&gt; m2 &lt;&gt; n2 &lt;&gt; m3 &lt;&gt; n3 &lt;&gt; ...
</pre><p>is sent to
</p><pre> (m1 &lt;&gt; m2 &lt;&gt; m3 &lt;&gt; ..., (act m1 n1) &lt;&gt; (act (m1 &lt;&gt; m2) n2) &lt;&gt; (act (m1 &lt;&gt; m2 &lt;&gt; m3) n3) &lt;&gt; ...)
</pre><p>That is, before combining <code>n</code> values, every <code>n</code> value is acted on
   by all the <code>m</code> values to its left.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.10.0</p></div></body></html>